filter {
  csv {
    autodetect_column_names => true
    convert => {
      "Connect" => "integer"
      "responseCode" => "integer"
      "bytes" => "integer"
      "IdleTime" => "integer"
      "Latency" => "integer"
      "sentBytes" => "integer"
      "elapsed" => "integer"
      "allThreads" => "integer"
      "success" => "boolean"
    }
  }

  #DROP HEADER Message
  if [timeStamp] {
    if [timeStamp] == "timeStamp" {
      drop {
      }
    }
  }

  #parse timeStamp
  if [timeStamp] {
    date {
      match => [ "timeStamp",  "UNIX_MS" ]
      target => ["timestamp"]
      remove_field => [ "timeStamp" ]
    }
  }

  #parse TESTSTART
  if [TESTSTART.MS] {
    date {
      match => [ "TESTSTART.MS",  "UNIX_MS" ]
      target => ["teststart"]
      remove_field => [ "TESTSTART.MS" ]
    }
  }


  #CLEAN NULL value

  ruby {
    code => "
      hash = event.to_hash
      hash.each { |key,value|
        if value == 'null'
           event.remove(key)
        end
      }
    "
  }
  #parse add relative tiemestamp

  if [teststart] and [timestamp] {
    ruby {
      code => " event.set('relativeTimeTMP', event.get('timestamp') - event.get('teststart')) "
    }
    date {
      match => [ "relativeTimeTMP",  "UNIX_MS" ]
      target => ["relativetime"]
      remove_field => [ "relativeTimeTMP" ]
    }
  }



  #parse url
  if [URL] {
    if [URL] =~ /^http(.)+/ {
      grok {
        match => {
          "URL" => ['\Ahttp(s|)://(?:%{HOSTPORT:host}|%{IPORHOST:domain})%{DATA:request}\Z']
        }
        tag_on_failure => ["_grokparsefailure","_grokparsefailure_url"]

      }
    }
  }

  #parse ThreadGroup
  if [threadName] {
    grok {
      match => {
        "threadName" => ['\A%{DATA:threadGrpName} %{INT:threadGrpCount}-%{INT:threadGrpTotal}\Z']
      }
      tag_on_failure => ["_grokparsefailure","_grokparsefailure_threadName"]

    }

  }

  #parse path
  if [path] {

    grok {
      match => {
        "path" => ['(\\|/)%{USERNAME:filename}.(jtl|csv|txt)\Z']
      }
      tag_on_failure => ["_grokparsefailure","_grokparsefailure_path"]

    }

    grok {
      patterns_dir => ["//usr/share/logstash/pipeline//pattern/grok"]
      match => {
        "filename" => ['\A%{TESTNAME:testname}-%{NODEID:node}-%{EXECUTIOND:executionid}\Z',
        '\A%{TESTNAME:testname}-%{EXECUTIOND:executionid}\Z','\A%{USERNAME:testname}\Z' ]
      }
      tag_on_failure => ["_grokparsefailure","_grokparsefailure_filename"]

    }
  }



  #parse Transaction
  if [URL] =~ /^_.*_$/ {
    mutate {
      add_field => [ "transaction", "true"  ]
    }
  }
  else {
    mutate {
      add_field => [ "transaction", "false"  ]
    }
  }

  mutate {
    convert => {
      "transaction" => "boolean"
    }
  }


  #add time if parse error
  if ![timestamp] {
    mutate {
      add_field => [ "timestamp", "%{@timestamp}"  ]
    }
  }

  mutate {
    copy => {
      "label" => "labels"
    }
  }
  mutate {
    split => {
      "labels" => "/"
    }
  }

}